#include <Arduino.h>
#include <Devices/EnvironmentSensor.h>
#include <Devices/MotionDetector.h>
#include <Devices/Radiator.h>

#include "ControllerInterface/RoomInterface.h"
// #include "Devices/Radiator.h"
// #include <esp_system.h>
#include <esp_task_wdt.h>
#include <Devices/BlueStalker.h>
// #include <esp32/rom/ets_sys.h>

// #define DEBUG 0

extern RoomInterface MainRoomInterface;

RoomInterface::TaskPile allHandles;

Radiator* radiator;
MotionDetector* motionDetector;
EnvironmentSensor* environmentSensor;

const char* task_state_to_string(const eTaskState state) {
    switch (state) {
        case eRunning: return "Running";
        case eReady: return "Ready";
        case eBlocked: return "Blocked";
        case eSuspended: return "Suspended";
        case eDeleted: return "Deleted";
        case eInvalid: return "Invalid";
        default: return "Unknown";
    }
}

const char* wifi_status_to_string(const wl_status_t status) {
    switch (status) {
        case WL_NO_SHIELD: return "No Shield";
        case WL_IDLE_STATUS: return "Idle";
        case WL_NO_SSID_AVAIL: return "No SSID Available";
        case WL_SCAN_COMPLETED: return "Scan Completed";
        case WL_CONNECTED: return "Connected";
        case WL_CONNECT_FAILED: return "Connect Failed";
        case WL_CONNECTION_LOST: return "Connection Lost";
        case WL_DISCONNECTED: return "Disconnected";
        default: return "Unknown";
    }
}

/**
 * Print the current time in the format mm/dd/yyyy hh:mm:ss
 * @param buffer Target string buffer
 */
void current_time(char* buffer) {
    time_t now;
    tm timeinfo;
    time(&now);
    localtime_r(&now, &timeinfo);
    strftime(buffer, 80, "%m/%d/%Y %H:%M:%S", &timeinfo);
}

void setup() {
    // _xtos_set_exception_handler(EXCCAUSE, reinterpret_cast<_xtos_handler>(exceptionHandler));
    Serial.begin(9600);
    Serial.println("Starting WiFi...");
    WiFi.mode(WIFI_MODE_STA);  // Setup wifi to connect to an access point
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD); // Pass the SSID and Password to the WiFi.begin function
    WiFi.setAutoReconnect(true); // Enable auto reconnect
    WiFi.setHostname("RoomDevice"); // Set the hostname of the device (doesn't seem to work)
    Serial.println("WiFi started.");
    if (WiFi.waitForConnectResult() != WL_CONNECTED) {
        Serial.println("WiFi failed to connect.");
        esp_restart();
        return;
    }
    // Set the time using the NTP protocol
    configTime(0, 0, "pool.ntp.org", "time.nist.gov");
    radiator = new Radiator();
    motionDetector = new MotionDetector();
    environmentSensor = new EnvironmentSensor();
    // delay(1000);
    Serial.println("Starting up all Tasks...");
    MainRoomInterface.begin();
    Serial.println("Task startup complete.");
    esp_task_wdt_init(10, true);
}

void loop() {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    allHandles = MainRoomInterface.getAllTaskHandles();
    while (true) {
#ifdef DEBUG
        Serial.println("Debug dump");
        Serial.println("--------------------");
        Serial.println("-Current Time");
        // Print the current time in mm/dd/yyyy hh:mm:ss format
        char buffer[80] = {0};
        Serial.printf("--Current Time: %s\n", buffer);
        Serial.println("-WiFi Information");
        Serial.printf("--WiFi Status: %s\n", wifi_status_to_string(WiFi.status()));
        Serial.printf("--WiFi RSSI: %d\n", WiFi.RSSI());
        Serial.printf("--WiFi Hostname: %s\n", WiFi.getHostname());
        Serial.printf("--WiFi IP: %s\n", WiFi.localIP().toString().c_str());

        Serial.println("-End WiFi Information");
        // Print the state of all the tasks generated by the room interface.
        Serial.printf("-Task Information [%d]\n", allHandles.count);
        if (allHandles.count == 0 || allHandles.count == -1) {
            Serial.println("No tasks found.");
            return;
        }
        for (int i = 0; i < allHandles.count; i++) {
            if (allHandles.handles[i] == nullptr) {
                // Serial.println("Null task handle.");
                // taskYIELD();
                continue;
            }
            const eTaskState task_info = eTaskGetState(*allHandles.handles[i]);
            Serial.printf("--Task %s [%d]: %s\n", allHandles.names[i] != nullptr ? allHandles.names[i] : "Unknown", i,
            task_state_to_string(task_info));
            // UBaseType_t taskCount = uxTaskGetNumberOfTasks();
            // TaskStatus_t *taskStatusArray = (TaskStatus_t *)pvPortMalloc(taskCount * sizeof(TaskStatus_t));
            // if (taskStatusArray != nullptr) {
            //     UBaseType_t arraySize = uxTaskGetSystemState(taskStatusArray, taskCount, nullptr);
            //     for (UBaseType_t i = 0; i < arraySize; i++) {
            //         Serial.printf("--Task %s [%d]: %s, CPU Time: %lu\n",
            //             taskStatusArray[i].pcTaskName,
            //             taskStatusArray[i].xTaskNumber,
            //             task_state_to_string(taskStatusArray[i].eCurrentState),
            //             taskStatusArray[i].ulRunTimeCounter);
            //     }
            //     vPortFree(taskStatusArray);
            // }
            // Serial.flush();
            taskYIELD();
        }
        // vTaskDelay(500);
        Serial.println("-End Task Information");

        Serial.println("--------------------");
#endif

        // vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(5000));
        vTaskDelay(5000);
    }
}